if문

if (조건식) {
		// 조건식이 참(true) 일 때 수행될 문장들을 적는다.
}


if-else문

if (조건식) {
		// 조건식이 참(true) 일 때 수행될 문장들을 적는다.
} else {
		// 조건식이 거짓(false) 일 때 수행될 문장들을 적는다.
}


if~else if문

if (조건식1) {
		// 조건식1의 연산결과가 참일 때 수행될 문장들을 적는다.
} else if (조건식2) {
		// 조건식2의 연산결과가 참일 때 수행될 문장들을 적는다.
} else if (조건식3) {			// 여러 개의 else if를 사용할 수 있다.
		// 조건식3의 연산결과가 참일 때 수행될 문장들을 적는다.
} else {	// 마지막에는 보통 else블럭으로 끝나며, else 블럭은 생략가능하다.
		// 위의 어느 조건식도 만족하지 않을 때 수행될 문장들을 적는다.
}


중첩 if문

if (조건식1) {
		// 조건식1의 연산결과가 true일 때 수행될 문장들을 적는다.
		if (조건식2) {
			// 조건식1과 조건식2가 모두 true일 때 수행될 문장들
		} else {
			// 조건식1이 true이고, 조건식2가 false일 때 수행되는 문장들
		}
} else {
		// 조건식1이 false일 때 수행되는 문장들
}


switch문
1) 조건식을 계산한다.
2) 조건식의 결과와 일치하는 case문으로 이동한다.
3) 이후의 문장들을 수행한다.
4) break문이나 switch문의 끝을 만나면 switch문 전체를 빠져나간다.

swtich문의 제약조건
1) switch문의 조건식 결과는 정수 또는 문자열이어야 한다.
2) case문의 값은 정수 상수만 가능하며, 중복되지 않아야 한다.

만일 조건식의 결과와 일치하는 case문이 하나도 없을 경우에는 default문으로 이동한다.
default문의 위치는 어디라도 상관없으나 보통 마지막에 놓기 때문에 break문을 쓰지 않아도 된다.
if문의 else블럭과 같은 역할을 한다고 보면 이해가 쉬울 것이다.

switch문에서 break문은 각 case문의 영역을 구분하는 역할을 한다.
break문을 생략하면 case문 사이의 구분이 없어지므로 다른 break문을 만나거나
switch문 블럭{}의 끝을 만날 때까지 나오는 모든 문장을 수행한다.
그러므로 각 case문의 마지막에 break문을 빼먹는 실수를 하지 않도록 주의해야한다.

고의적으로 break문을 생략하는 경우도 있는데,
회원 등급에 맞는 권한을 부여하는 방식인 경우이다.


switch (조건식) {
		case 값 :
			// 조건식의 결과가 값1과 같을 경우 수행될 문장들
			// ...
			break;
		case 값2 :
			// 조건식의 결과가 값2와 같을 경우 수행될 문장들
			// ...
			break;		// switch문을 벗어난다.
		// ...
		default :
			// 조건식의 결과와 일치하는 case문이 없을 때 수행될 문장들
			// ...
}


Math.random() : 난수(임의의 수)를 얻기 위해 사용하는 메서드
				   0.0과 1.0사이의 범위에 속하는 하나의 double값을 반환한다.
				   0.0 <= Math.random() < 1.0

만일 1 과 3 사이의 정수를 구하기를 원한다면,
다음과 같은 과정으로 난수를 구하는 식을 얻을 수 있다.

1) 각 변에 3을 곱한다.
0.0 * 3 <= Math.random() * 3 < 1.0 * 3
	   0.0 <= Math.random() * 3 < 3.0

2) 각 변을 int형으로 반환한다.
(int)0.0 <= (int)(Math.random() * 3) < (int)3.0
		  0 <= (int)(Math.random() * 3) < 3

3) 각 변에 1을 더한다.
0 + 1 <= (int)(Math.random() * 3) + 1 < 3 + 1
	   1 <= (int)(Math.random() * 3) + 1 < 4

주사위를 던졌을 때 나타는 임의의 값을 얻기 위해서는 3 대신 6을 곱하면 된다.


문자열에 저장된 문자는 '문자열.charAt(index)'로 가져올 수 있는데,
index는 연속된 정수값으로 1이 아닌 0부터 시작한다.

char타입의 값은 사실 문자가 아닌 정수(유니코드)로 저장되기 때문에
이처럼 char타입의 값도 switch문의 조건식과 case문에 사용할 수 있다.


switch문의 중첩
if문처럼 switch문도 중첩이 가능하다.
한 가지 주의할 점은 중첩 switch문에서 break문을 빼먹기 쉽다는 것이다.


for문

for문의 구조와 수행순서
조건식이 참인 동안 블럭{} 내의 문장들을 반복하다 거짓이 되면 반복문을 벗어난다.

for (초기화; 조건식; 증감식) {
		// 조건식이 참일 때 수행될 문장들을 적는다.
}


- 초기화
반복문에 사용될 변수를 초기화하는 부분이며 처음에 한 번만 수행된다.
보통 변수 하나로 for문을 제어하지만,
둘 이상의 변수가 필요할 때는 콤마를 구분자로 변수를 초기화하면 된다. (단, 두 변수의 타입은 같아야 한다.)

for (int i = 1; i <= 10; i++) { ... }		// 변수 i의 값을 1로 초기화 한다.
for (int i = 1, j = 0; i <= 10; i++) { ... }	// int타입의 변수 i와 j를 선언하고 초기화

- 조건식
for의 뜻이 '~하는 동안'이므로 조건식이 '참인 동안' 반복을 계속한다고 생각하면 쉽다.
조건식을 잘못 작성하면 블럭{} 내의 문장이 한 번도 수행되지 않거나 무한반복에 빠지기 쉬우므로 주의해야 한다.

for (int i = 1; i <= 10; i++) { ... }	// 'i <= 10'가 참인 동안 블럭{} 안의 문장들을 반복

- 증감식
반복문을 제어하는 변수의 값을 증가 또는 감소시키는 식이다.

for (int i = 1; i <= 10; i++) { ... }	// 1부터 10까지 1씩 증가
for (int i = 10; i > 1; i--) { ... }		// 10부터 1까지 1씩 감소
for (int i = 1; i <= 10; i+= 2) { ... }	// 1부터 10까지 2씩 증가
for (int i = 1; i <= 10; i*= 3) { ... }	// 1부터 10까지 3배씩 증가

증감식도 쉼표를 이용해서 두 문장 이상을 하나로 연결해서 쓸 수 있다.

for (int i = 1, j = 10; i <= 10; i++, j--) { ... }	// i는 1부터 10까지 1씩 증가하고
														// j는 1부터 10까지 1씩 감소한다.

초기화, 조건식, 증감식은 필요하지 않으면 생략할 수 있으며, 모두 생략도 가능하다.
for (;;) { ... }	// 초기화, 조건식, 증감식 모두 생략. 조건식은 참이 되고 무한 반복문이 된다.
대신 블럭{} 안에 if문을 넣어서 특정 조건을 만족하면 for문을 빠져 나오게 해야 한다.


for문에 사용되는 변수의 수가 적은 것이 더 효율적이고 간단하므로
변수들의 관계를 잘 파악하여 불필요한 변수를 줄이는 것이 좋다.


나머지 연산자 % 를 사용하면 특정 범위의 값들이 순환하면서 반복되는 결과를 얻을 수 있다
나누기 연산자 / 는 같은 값이 연속적으로 반복되게 할 수 있다

짝수 (2*i), 홀수 (2*i+1), 제곱 (i*i), 역순 (11-i), 순환 (i%3),  반복 (i/3)


향상된 for문
JDK1.5부터 배열과 컬렉션에 저장된 요소에 접근할 때
기존보다 편리한 방법으로 처리할 수 있도록 for문의 새로운 문법이 추가되었다.

for (타입 변수명 : 배열 또는 컬렉션) {
		//	반복할 문장
}

향상된 for문은 배열이나 컬렉션에 저장된 요소들을 읽어오는 용도로만 사용할 수 있다는 제약이 있다.


while문
while (조건식) {
			//	조건식의 연산결과가 참 (true)인 동안, 반복될 문장들을 적는다.
}

while문의 조건식은 생략불가
조건식이 항상 참이 되게 하려면 true를 넣어야 한다.


do-while문
while문에서 조건식과 블럭{}의 순서를 바꿔놓은 것이다.
블럭{} 수행한 후에 조건식 평가
최소한 한 번은 수행될 것을 보장한다.

do {
		// 조건식의 연산결과가 참일 때 수행될 문장을 적는다.
} while (조건식);	<- 끝에 ';'을 잊지 않도록 주의


break문
자신이 포함된 가장 가까운 반목문을 벗어난다.
주로 if문과 함께 사용되어 특정 조건을 만족하면 반복문을 벗어나도록 한다.


continue문
반복문 내에서만 사용될 수 있다.
반복이 진행되는 도중에 continue문을 만나면 반복문의 끝으로 이동하여 다음 반복으로 넘어간다.
for문의 경우 증감식으로 이동하고,
while문과 do-while문은 조건식으로 이동한다.

반복문 전체를 벗어나지 않고 다음 반복을 계속 수행한다는 점이 break문과 다르다.

주로 if문과 함께 사용되어 특정 조건을 만족하는 경우에
continue문 이후의 문장들을 수행하지 않고 다음 반복으로 넘어가서 계속 진행하도록 한다.

전체 반복 중에 특정조건을 만족하는 경우를 제외하고자 할 때 유용하다.


이름 붙은 반복문
break문은 근접한 단 하나의 반복문만 벗어날 수 있기 때문에,
여러 개의 반복문이 중첩된 경우에는 break문으로 중첩 반복문을 벗어날 수 없다.

이때는 중첩 반복문 앞에 이름을 붙이고 break문과 continue문에 이름을 지정해 줌으로써
하나 이상의 반복문을 벗어나거나 반복을 건너뛸 수 있다.

